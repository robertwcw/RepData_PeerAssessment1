---
title: "RepData_PeerAssessment1"
author: "robertwcw"
date: "9/7/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
    Sys.setenv(TZ = "UTC")  # set global TZ for POSIXt class
	.Rfliburl <- "https://raw.githubusercontent.com/robertwcw/Rflib/master"
	source(file.path(.Rfliburl,"getRflib.R"),local = TRUE)
	source(getRflib("is.defined.R"),local = TRUE)
	source(getRflib("myplclust.R"),local = TRUE)
	source(getRflib("strCap.R"),local = TRUE)
	library(dplyr, warn.conflicts = TRUE, quietly = TRUE)
	library(lubridate, warn.conflicts = TRUE, quietly = TRUE)
	library(ggplot2, warn.conflicts = TRUE, quietly = TRUE)
	library(scales, warn.conflicts = TRUE, quietly = TRUE)
```
&nbsp;

## Introduction

This assignment makes use of the data collected from a personal activity monitoring device strapped to the waist, captures data at 5 minute intervals through out the day on the number of steps taken by an anonymous individual in daily activities during the months of November and October in 2012. The device that was used to capture the steps data is part of the “quantified self” movement – a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks. 

The data set in CSV format is available here: [Activity monitoring data](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip).

Each row in the data set consists of three variables recorded the total number of steps taken in daily activities in every 5 minutes interval spanned across 24 hours each day for two consecutive months. The context of the steps taken in daily activities is referring to the body movements like walking (include up/down stairs), running or jumping.

The variables found in the data set are:  
1. **steps**: Number of steps taken by the anonymous individual in 5-minute interval.  
2. **date**: The date (YYYY-MM-DD) which the measurements were taken.  
3. **interval**: Identifier for the 5-minute interval for which the observation was captured.
&nbsp;

### Loading and Preprocessing Data

1. download data set and unzip to designated directory.  
2. take-a-peek at the unzipped data set to determine number of files, file type, data format and the presence of header...etc, to determine the  appropriate technique to process the 'raw' data into analytic data for downstream analysis.

<!-- as.list(unzip(filetmp, list = TRUE)) #get a list of file names -->
<!-- length(filels$Name) #display number of files in the zip file -->
<!-- filels$Name #display file name & file type. -->
<!-- filels$Length #display physical file size -->
<!-- readLines(filels$Name[i], n = 5) #display first 5 lines. (text-file only) -->
<!-- length(readLines(filels$Name[i])) - 1 #display row count (text-file only) -->

```{r data.load, message = FALSE}
# begin data loading

filetmp <- tempfile()
datadir <- paste(".", "data", sep = "/")
fileurl <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
download.file(fileurl, filetmp)

if (!dir.exists(datadir)) 
    {
        dir.create(datadir)
    }

unzip(filetmp, exdir = datadir, overwrite = TRUE)
filels <- as.list(unzip(filetmp, list = TRUE))
filein <- as.character()
filesrc <- as.character()

for (i in 1:length(filels$Name)) 
    {
        filesrc <- paste(datadir, filels$Name[[i]], sep = "/")
        filein <- strsplit(filels$Name[[i]], ".", fixed = TRUE)[[1]][1]
        assign(filein, read.csv(filesrc))
    }

unlink(filetmp)
rm(filetmp, fileurl, filein, filesrc, i)

# end of data loading
```

One data set named **activity** was extracted from the downloaded zip file and loaded into R.  

Data structure of **activity**:

```{r data.eval0}
str(activity)
```

* **activity** variable data type.
  + **steps**: integer class.
  + **date**: character class.
  + **interval**: integer class.
  
Take note that the variable **date** shall belonged to the date class data type instead of the current character class data type for which date values are stored as character string. Time-series related analysis requires that the **date** variable be transformed into formal date class vector to warrant proper analysis.

*5-numbers summary*
```{r data.eval1}
summary(activity)
```

*Missing value distribution*
```{r data.evl2}
colMeans(is.na(activity))
```

```{r data.eval2, echo = FALSE, results = "hide"}
na.count <- sum(is.na(activity$steps)) + 
            sum(is.na(activity$date)) + 
            sum(is.na(activity$interval))
na.ratio <- mean(is.na(activity$steps)) +
            mean(is.na(activity$date)) +
            mean(is.na(activity$interval))
```

The 5-numbers summary of **activity** data set shows there are `r na.count` missing values (coded as NA), representing approx. `r percent(na.ratio)` missing values present in the data set. The ratio of missing values considered significant in this case which can skewed the outcomes of downstream analysis.

Missing value distribution, not in the usual sense of statistical distribution, simply reveals how the missing values are scattered in the data set.  
- **steps**: contains `r percent(colMeans(is.na(activity))[1])` missing value.  
- **date**: `r percent(colMeans(is.na(activity))[2])`.  
- **interval**: `r percent(colMeans(is.na(activity))[3])`.  
```{r}
rm(na.count, na.ratio)
```

```{r data.prep} 
# begin data preparation

names(activity) <- strCap(names(activity))  # capitalize variable names.

# hr <- activity$Interval %/% 100 # e.g. 2355 gives 23
# mn <- activity$Interval %% 100 # e.g 2355 gives 55

# transform Date variable to 'date' class and add Time variable of POSIXt
time.hms <- substr(as.POSIXct(sprintf("%04.0f", activity$Interval), format = '%H%M'), 12, 19)
date.time <- as.POSIXct(paste(activity$Date, time.hms))
activity <- activity %>%
            mutate(Date = as.Date(Date), Time = date.time) %>%
            arrange(Time)

# create daily activity summary
actsum <- activity %>% 
                select(Date, Steps) %>%
                mutate(Mean = as.numeric(0),
                       Median = as.numeric(0)) %>%
              group_by(Date) %>% 
             summarise(Mean = mean(Steps, na.rm = TRUE),
                       Median = median(Steps, na.rm = TRUE),
                       Steps = sum(Steps, na.rm = TRUE))

rm(time.hms, date.time)

# end of data preparation
```
&nbsp;

### What is mean total number of steps taken per day?

There are missing bar-columns *( for dates Oct-01, Oct-08, Nov-01, Nov-04, Nov-09, Nov-10, Nov-14 and Nov-30 )* in the histogram due to the presence of missing values in the data set as mentioned.

```{r steps.hist.plot}
# begin daily activity hisogram plot

h <- hist(actsum$Date_num, breaks = "days", freq = FALSE, plot = FALSE)
h$counts <- actsum$Steps

par(cex.axis = 0.8, las = 2)
plot(h, xaxt = "n", ann = FALSE, col = "grey")
axis(1, at = seq(h$breaks[1], h$breaks[length(h$breaks)], by = 5), 
     labels = c(format(as.Date(seq(h$breaks[1], h$breaks[length(h$breaks)], 
                                   by = 5 ), origin = "1970-01-01"), "%b-%d")))
abline(h = mean(actsum$Steps), col = "red")
abline(h = median(actsum$Steps), col = "green")
legend("topleft", legend = c("Mean", "Median"), 
       lty = c(1,1,1), col = c("red","green"), cex = 0.75)
title(main = "Number of Steps Taken Per Day", 
      sub = "( Year 2012 )",
      xlab = "Date", 
      ylab = "Daily Steps Count",
      cex = 1)

# end of daily activity histogram plot
```

```{r steps.hist.ggplot, include=FALSE, echo=FALSE, results="hide"}
# begin daily steps histogram ggplot

# gr0 <- ggplot(actsum, aes(x = Date, y = Steps, fill = Steps))
gr0 <- ggplot(actsum, aes(x = Date, y = Steps))
gr0 <- gr0 + geom_col()
gr0 <- gr0 + scale_x_date(breaks = breaks_pretty(11))
gr0 <- gr0 + theme(plot.title = element_text(hjust = 0.5),
                   plot.subtitle = element_text(hjust = 0.5),
                   axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
gr0 <- gr0 + labs(title = "Number of Steps Taken Per Day",
                  subtitle = "(October & November, 2012)")
gr0 <- gr0 + xlab("Date") + ylab("Daily Steps Count")
gr0 <- gr0 + geom_hline(data = actsum,
                        aes(yintercept = mean(Steps), col = "Mean"))
gr0 <- gr0 + geom_hline(data = actsum,
                        aes(yintercept = median(Steps), col = "Median"))
gr0 <- gr0 + scale_color_discrete(name = "Central Tendency")
print(gr0)

# end of daily activity histogram ggplot
```
**
The total number of steps taken per day by the anonymous are illustrated in the histogram, where each bar in the graph represents the total steps count recorded each day. The mean and median of the steps count observations accumulated over the two months period as portrayed by the visual representation of the red and green horizontal lines overlaid on the histogram, hovering around the 10,000 mark indicate that the anonymous individual performed, on average ``r format(mean(actsum$Steps),nsmall=2)``, close to 10,000 steps per day in daily activities. The median value ``r format(median(actsum$Steps),nsmall=2)`` floating slightly above the 10,000 mark.
**
&nbsp;

<!-- 
frequency param setting for ts()
interval	frequency
annually        1
quarterly       4
monthly        12
weekly         52
daily         365.25
the frequency is the number of observations per cycle (normally a year, a week, a day or an hour).

if the frequency of observation is greater than once in a day, then there is more than one way of handling the frequency. e.g. data with per minute observation might have an hourly seasonality (frequency = 1 x 60), a daily seasonality (frequency = 1 x 60 x 24), a weekly seasonality (frequency = 1 x 60 x 24 x 7) and an annual seasonality (frequency = 1 x 60 x 24 x 365.25).

i.e.    frequency determines the number of observations per cycle, and therefore the number of cycle (number of observations / frequency) in the time series.

start param setting for ts()
i.e. start(m,n) where m = the number of the first cycle 
                      n = the starting nth incident for that first cycle
end(m,n) where m = the number of the last cycle
               n = the ending nth incident for that last cycle
      
e.g.
ts(actsum, 
        start = c(year(min(actsum$Date)), yday(min(actsum$Date))),
        end = c(year(max(actsum$Date)), yday(max(actsum$Date))),
        frequency = 365)

ts(activity,
        start = c(1,1),
        end = c(17568/(12*24), 12*24),
        frequency = 12*24)
-->

### What is the average daily activity pattern?

```{r ts0.plot, include=FALSE, echo=FALSE, results="hide"}
# time series plot for daily activity pattern

pal <- c(rgb(0,0,1), rgb(0,1,0), rgb(1,0,0), rgb(1,0,1), rgb(1,1,0), rgb(0,1,1))

activity.ts <- aggregate(Steps ~ Interval, data = activity, FUN = mean)

par(cex.axis = 0.8, las = 2)
plot(activity.ts, type = "l", col = "royalblue3")
h <- activity.ts[which(activity.ts$Steps == max(activity.ts$Steps)),]
abline(v = h$Interval, col = pal[3])
title(main = "Average Daily Activities Pattern", 
      # sub = "( data points plotted @ 5-min interval )",
      xlab = "Time Interval", 
      ylab = "Steps Count",
      cex = 0.9,
      cex.sub = 0.7)
```

```{r ts.plot}
# time series plot for daily activity pattern

activity.ts <- ts(aggregate(Steps ~ Interval, data = activity, FUN = mean))

pal <- c(rgb(0,0,1), rgb(0,1,0), rgb(1,0,0), rgb(1,0,1), rgb(1,1,0), rgb(0,1,1))

par(cex.axis = 0.8, las = 2, ann = FALSE)
plot(activity.ts[,2] ~ activity.ts[,1], type = "l", col = "royalblue3")
h <- activity.ts[which(activity.ts[,2] == max(activity.ts[,2])),]
abline(v = h[1], col = pal[3])
title(main = "Average Daily Activities Pattern", 
      xlab = "Time Interval", 
      ylab = "Steps Count",
      cex = 0.9,
      cex.sub = 0.7)
```
&nbsp;

### Imputing missing values

k-nearest neighbour imputation method to impute the missing values found in the activity data set.
k = sqrt(17568)/2, generally accepted method to determine k-value for knn.impute()

```{r data.impute}

library(impute)
activity.imputed <- impute.knn(data.matrix(activity[,1:3]), k = 65)$data
detach("package:impute", unload = TRUE)

activity.imputed <- as.data.frame(activity.imputed)
activity.imputed <- mutate(activity.imputed, Time = activity$Time)

```

5-numbers summary on 'activity' data set reveals that missing values 'NA' had been imputed with k-nearest neighbour imputation method where k = 15 is used.

```{r}
# summary(activity)
# colMeans(activity)
```

```{r imputed.activity.hist.plot}
# begin imputed daily activity histogram plot

# create imputed daily activity summary
actsum <- activity.imputed %>% 
                select(Date, Steps) %>%
                mutate(Date = as_date(Date),
                       Mean = as.numeric(0),
                       Median = as.numeric(0)) %>%
              group_by(Date) %>% 
             summarise(Mean = mean(Steps),
                       Median = median(Steps),
                       Steps = sum(Steps))

h <- hist(actsum$Date, breaks = "days", freq = FALSE, plot = FALSE)
h$counts <- actsum$Steps

par(cex.axis = 0.8, las = 2)
plot(h, xaxt = "n", ann = FALSE, col = "grey")
axis(1, at = seq(h$breaks[1], h$breaks[length(h$breaks)], by = 5), 
     labels = c(format(as.Date(seq(h$breaks[1], h$breaks[length(h$breaks)], 
                                   by = 5 ), origin = "1970-01-01"), "%b-%d")))
abline(h = mean(actsum$Steps), col = "red")
abline(h = median(actsum$Steps), col = "green")
legend("topleft", legend = c("Mean", "Median"), 
       lty = c(1,1,1), col = c("red","green"), cex = 0.75)
title(main = "Number of Steps Taken Per Day", 
      sub = "( Year 2012 )",
      xlab = "Date", 
      ylab = "Daily Steps Count",
      cex = 1)

# end of imputed daily activity histogram plot
```
&nbsp;

### Activity pattern between weekdays and weekends

```{r}

dow <- wday(as_date(activity.imputed$Date), week_start = 1)
activity.imputed <- activity.imputed %>% 
        mutate(wday_type = as.factor(if_else(dow %in% c(6,7),"weekend","weekday")))
rm(dow)

activity.imputed <- activity.imputed %>% group_by(wday_type)


```

```{r house.keeping}
# detach("package:ggplot2", unload = TRUE)
# detach("package:scales", unload = TRUE)
# detach("package:dplyr", unload = TRUE)
# detach("package:lubridate", unload = TRUE)
# rm(.Rfliburl)
# rm(getRflib)
# rm(is.defined)
# rm(myplclust)	
# rm(strCap)
```
